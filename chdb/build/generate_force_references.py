#!/usr/bin/env python3
"""
Auto-generate ForceFunctionReferences.cpp by scanning all REGISTER_FUNCTION calls
in src/Functions directory and subdirectories.
"""
import os
import re
from pathlib import Path

GLOBAL_NAMESPACE_FUNCTIONS = {
    'IsValidASCII'
}

def extract_register_functions(functions_dir):
    """Extract all REGISTER_FUNCTION calls from Functions directory recursively"""
    register_functions = set()

    # Functions that cause linker errors due to missing dependencies
    excluded_functions = {
        'UniqTheta',
        'Idna',
        'Sqid',
        'Stem',
        'Trap',
        'BuildId',
        'GeoToS2',
        'S2ToGeo',
        'Coverage',
        'Punycode',
        'Synonyms',
        'Lemmatize',
        'LowerUTF8',
        'S2RectAdd',
        'UpperUTF8',
        'S2CapUnion',
        'S2RectUnion',
        'Base64Decode',
        'Base64Encode',
        'GenerateULID',
        'AddressToLine',
        'DetectCharset',
        'GetFuzzerData',
        'NormalizeUTF8',
        'S2CapContains',
        'ConvertCharset',
        'DetectLanguage',
        'DetectTonality',
        'S2GetNeighbors',
        'S2RectContains',
        'AddressToSymbol',
        'Base64URLDecode',
        'Base64URLEncode',
        'IcebergTruncate',
        'TryBase64Decode',
        'S2CellsIntersect',
        'S2RectIntersection',
        'TryBase64URLDecode',
        'SeriesPeriodDetectFFT',
        'AddressToLineWithInlines',
        'DetectProgrammingLanguage',
        'GenerateUUIDv7',
        'ToTime',
        'ToTimeWithFixedDate',
        'Bech32Repr',
        'DateTimeToUUIDv7',
        'GenerateULID',
        'ULIDStringToDateTime'
    }

    # Walk through all subdirectories
    for root, dirs, files in os.walk(functions_dir):
        for file in files:
            if not file.endswith('.cpp'):
                continue

            cpp_file = os.path.join(root, file)
            try:
                with open(cpp_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Find REGISTER_FUNCTION(FunctionName) patterns
                matches = re.findall(r'REGISTER_FUNCTION\s*\(\s*(\w+)\s*\)', content)
                for match in matches:
                    # Skip excluded functions
                    if match not in excluded_functions:
                        register_functions.add(match)

            except Exception as e:
                print(f"Warning: Could not process {cpp_file}: {e}")

    return sorted(register_functions)

def generate_force_references_code(register_functions):
    """Generate C++ code to force function registration references"""

    # Separate functions by namespace
    db_namespace_funcs = [f for f in register_functions if f not in GLOBAL_NAMESPACE_FUNCTIONS]
    global_funcs = [f for f in register_functions if f in GLOBAL_NAMESPACE_FUNCTIONS]

    code_lines = [
        '/// Auto-generated file - DO NOT EDIT MANUALLY',
        '/// Generated by ForceFunctionReferences.py',
        '/// Force references to function registration functions to ensure linking',
        '/// This prevents the linker from excluding object files containing REGISTER_FUNCTION',
        '',
        'namespace DB',
        '{',
        '    class FunctionFactory;',
        '}',
        ''
    ]

    # Forward declarations for functions in global namespace (upstream bugs)
    if global_funcs:
        code_lines.append('/// Functions defined in global namespace (upstream bugs)')
        for func_name in global_funcs:
            code_lines.append(f'extern void registerFunction{func_name}(::DB::FunctionFactory & factory);')
        code_lines.append('')

    code_lines.extend([
        'namespace DB',
        '{',
        '',
        '    /// Forward declarations of function registration functions',
        '    /// These functions have external linkage and can be referenced'
    ])

    # Forward declarations of registration functions in DB namespace
    for func_name in db_namespace_funcs:
        code_lines.append(f'    extern void registerFunction{func_name}(FunctionFactory & factory);')

    code_lines.extend([
        '',
        '    /// Force references to ensure function registration functions are linked',
        '    void * ForceStaticRegistrationObjects()',
        '    {',
        '        /// Create function pointer array to force linking',
        '        static void (*registration_funcs[])(FunctionFactory &) =',
        '        {'
    ])

    # Registration function references - global namespace functions first
    for func_name in global_funcs:
        code_lines.append(f'            &::registerFunction{func_name},')

    # Then DB namespace functions
    for func_name in db_namespace_funcs:
        code_lines.append(f'            &registerFunction{func_name},')

    code_lines.extend([
        '            nullptr',
        '        };',
        '',
        '        /// Return pointer to prevent compiler optimization',
        '        return static_cast<void *>(registration_funcs);',
        '    }',
        '}',
        ''
    ])

    return '\n'.join(code_lines)

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))

    functions_dir = os.path.join(script_dir, "../../src/Functions")
    output_file = os.path.join(script_dir, "../../programs/local/ForceFunctionReferences.cpp")

    if not os.path.exists(functions_dir):
        print(f"Error: Functions directory not found: {functions_dir}")
        return 1

    print(f"Scanning {functions_dir} for REGISTER_FUNCTION calls...")
    register_functions = extract_register_functions(functions_dir)

    print(f"Found {len(register_functions)} unique function registrations")

    # Generate the force references code
    force_code = generate_force_references_code(register_functions)

    # Write to output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(force_code)

    print(f"\nGenerated: {output_file}")

    return 0

if __name__ == "__main__":
    exit(main())
